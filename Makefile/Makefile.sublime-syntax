%YAML 1.2
---
# http://www.sublimetext.com/docs/3/syntax.html
# Converted from Makefile Improved by Kay-Uwe (Kiwi) Lorenz
# Includes a few improvement like special-target, a bit more shell command,
# better variable recognition, fix ifeq/ifneq missing highlight ...
# Rewritten by Raoul Wols on May 2017.
# 
# All number references refer to the "Make manual" located at
# https://www.gnu.org/software/make/manual/make.html
name: Makefile
file_extensions:
  - make
  - GNUmakefile
  - makefile
  - Makefile
  - OCamlMakefile
  - mak
  - mk
first_line_match: ^#!\s*/usr/bin/make\b
scope: source.makefile
variables:
  
  varassign: (\?|\+|::?)?=
  shellassign: '!='
  startdirective: ifn?(def|eq)
  include: '[s-]?include'
  ruleassign: :(?!=)

  # The big "rule lookahead". What we want to do is here is detect if the
  # line that we are parsing is going to define a rule. So we need to check
  # if we have something of the form <rule-name> : <rule-prerequisites>
  # However matters become complicated by the fact that we can have arbitrary
  # variable substitutions anywhere. We try to remedy this by hacking in a
  # regex that matches up to four levels of nested parentheses, and ignores
  # whatever's inside the parentheses.
  nonparenchar: '[^()]'
  nps: '{{nonparenchar}}*'
  # Eats up to 4 nested parens
  paren_eater: (?:\({{nps}}*(?:\({{nps}}*(?:\({{nps}}*(?:\({{nps}}*\))?{{nps}}*\))?{{nps}}*\))?{{nps}}\))?
  just_eat: '{{nps}}{{paren_eater}}{{nps}}'
  rule_lookahead: '{{just_eat}}{{ruleassign}}{{just_eat}}'

  var_lookahead_base: '{{just_eat}}({{varassign}}|{{shellassign}}){{just_eat}}'
  # Just as with rules we want to look ahead if we are going to define a var.
  # However, due to the possibility of "target-specific" variables (see 6.11),
  # we want to NOT match if there's a {{ruleassign}} before a {{varassign}}.
  var_lookahead: (?!{{rule_lookahead}}){{var_lookahead_base}}

  first_assign_then_colon: '{{just_eat}}{{varassign}}{{just_eat}}{{ruleassign}}{{just_eat}}'
contexts:

  # 3.1 What Makefiles Contain
  # Makefiles contain five kinds of things: explicit rules, implicit rules, 
  # variable definitions, directives, and comments.
  main:
    - include: comments
    - include: variable-definitions
    - match: (?={{rule_lookahead}})
      push: expect-rule
    - include: function-invocations
    - include: control-flow
    - match: ^\s*(endef)
      captures:
        1: invalid.illegal.stray.endef.makefile

  inside-control-flow:
    - meta_scope: meta.group.makefile
    - match: "'"
      scope: punctuation.definition.string.begin.makefile
      push:
        - meta_scope: string.quoted.single.makefile
        - match: "'"
          scope: punctuation.definition.string.end.makefile
          pop: true
        - include: escape-literals
        - include: line-continuation
        - include: variable-substitutions
    - match: '"'
      scope: punctuation.definition.string.begin.makefile
      push:
        - meta_scope: string.quoted.double.makefile
        - match: '"'
          scope: punctuation.definition.string.end.makefile
          pop: true
        - include: escape-literals
        - include: line-continuation
        - include: variable-substitutions
    - match: \(
      scope: punctuation.section.group.begin.makefile
      push:
        - match: \)
          scope: punctuation.section.group.end.makefile
          pop: true
        - include: variable-substitutions
        - match: \,
          scope: punctuation.separator.makefile
    - match: \)
      scope: invalid.illegal.stray.paren.makefile
    - include: continuation-or-pop-on-line-end

  control-flow:
    - match: ^\s*(vpath)\s
      captures:
        1: keyword.control.vpath.makefile
      push:
        - include: highlight-wildcard-sign
        - match: \s
          set:
            - meta_content_scope: string.unquoted.makefile
            - include: pop-on-line-end
        - include: pop-on-line-end
    - match: ^\s*(vpath)$
      captures: keyword.control.vpath.makefile
    - match: ^\s*({{include}})\b
      captures:
        1: keyword.control.import.makefile
      push:
        - meta_content_scope: string.unquoted.makefile
        - include: continuation-or-pop-on-line-end
        - include: variable-substitutions
        - include: comments
    - match: \b{{startdirective}}\b
      scope: keyword.control.conditional.makefile
      push: inside-control-flow
    - match: ^\s*(else)\b
      captures:
        1: keyword.control.conditional.makefile
      push:
        - include: control-flow
        - include: comments
        - include: pop-on-line-end
    - match: ^\s*(endif)\b
      captures:
        1: keyword.control.conditional.makefile
      push:
        - include: comments
        - include: pop-on-line-end

  highlight-percentage-sign:
    - match: \%
      scope: variable.language.makefile

  highlight-wildcard-sign:
    - match: \*
      scope: variable.language.wildcard.makefile

  expect-rule:
    # Anything before the colon is part of the rule's name.
    - meta_scope: meta.function.makefile entity.name.function.makefile
    - include: line-continuation
    - include: variable-substitutions
    - include: highlight-percentage-sign
    - match: (?= *::?[^=]+[!:?]?=)
      set:
        - match: ::?
          scope: keyword.operator.assignment.makefile
          set:
            - include: variable-definitions
            - include: variable-substitutions
            - include: continuation-or-pop-on-line-end
    - match: (?= *::?)
      set:
        - match: ::?
          scope: keyword.operator.assignment.makefile
          set:
            - meta_content_scope: meta.function.arguments.makefile string.unquoted.makefile
            - include: line-continuation
            - include: variable-substitutions
            - include: highlight-percentage-sign
            - match: (?=#)
              set:
                - match: \#
                  scope: punctuation.definition.comment.makefile
                  set:
                    - meta_scope: comment.line.number-sign.makefile
                    - match: $
                      set: recipe-junction-between-spaces-or-tabs
            - match: $
              set: recipe-junction-between-spaces-or-tabs
            - match: ;
              scope: punctuation.separator.end.makefile
              set: recipe-inline

  recipe-junction-between-spaces-or-tabs:
    - meta_content_scope: meta.function.body.makefile
    - include: comments
    - match: ^\s*({{startdirective}})
      captures:
        1: keyword.control.conditional.makefile
      push:
        - include: inside-control-flow
        - include: recipe-junction-between-spaces-or-tabs
    - match: ^(?=[ ]+([-@]{1,2})?)
      set: recipe-with-spaces
    - match: ^(?=\t([-@]{1,2})?)
      set: recipe-with-tabs
    - match: ^
      pop: true

  recipe-inline:
    - include: recipe-junction-between-spaces-or-tabs
    - include: control-flow

  recipe-with-spaces:
    - meta_content_scope: meta.function.body.makefile
    - match: ^([ ]+)([-@]{1,2})?
      captures:
        2: constant.language.makefile
      push: scope:source.shell
      with_prototype:
        - include: line-continuation
        - include: variable-substitutions
        - include: pop-on-line-end
    - match: ^(\t)([-@]{1,2})?
      captures:
        1: invalid.illegal.inconsistent.expected.spaces.makefile
        2: constant.language.makefile
    - include: recipe-common
    - match: ^(?![ ]+)
      pop: true

  recipe-with-tabs:
    - meta_content_scope: meta.function.body.makefile
    - match: ^\t([-@]{1,2})?
      captures:
        1: constant.language.makefile
      push: scope:source.shell
      with_prototype:
        - include: line-continuation
        - include: variable-substitutions
        - include: pop-on-line-end
    - match: ^([ ]+)([-@]{1,2})?
      captures:
        1: invalid.illegal.inconsistent.expected.tab.makefile
        2: constant.language.makefile
    - include: recipe-common
    - match: ^(?!\t)
      pop: true

  recipe-common:
    - include: control-flow
    - match: ^\n

  line-continuation:
    - match: (\\)([ ]*)$\n?
      captures:
        1: punctuation.separator.continuation.line.makefile
      # make sure to resume parsing at next line
      push:
        - match: (?=\S|^\s*$)
          pop: true

  pop-on-line-end:
    - match: $
      pop: true

  continuation-or-pop-on-line-end:
    - include: line-continuation
    - include: pop-on-line-end

  quoted-string:
    - match: "'"
      scope: punctuation.definition.string.begin.makefile
      push:
        - meta_scope: string.quoted.single.makefile
        - match: "'"
          scope: punctuation.definition.string.end.makefile
          pop: true
        - include: escape-literals
        - include: line-continuation
        - include: variable-substitutions
    - match: '"'
      scope: punctuation.definition.string.begin.makefile
      push:
        - meta_scope: string.quoted.double.makefile
        - match: '"'
          scope: punctuation.definition.string.end.makefile
          pop: true
        - include: escape-literals
        - include: line-continuation
        - include: variable-substitutions

  escape-literals:
    - match: \\.
      scope: constant.character.escape.makefile

  comments:
    # This hack is here in order to circumvent false-positives for the big
    # rule lookahead. For example, if this match is not present, then things
    # like
    # 
    #     # A comment with a : colon
    #     
    # will match the rule-lookahead.
    - match: (?=^\s*#)
      push:
        - match: \#
          scope: punctuation.definition.comment.makefile
          set:
            - meta_scope: comment.line.number-sign.makefile
            - include: pop-on-line-end
    # This is the "normal" comment parsing logic, but not sufficient in every
    # case (see above).
    - match: \#
      scope: punctuation.definition.comment.makefile
      push:
        - meta_scope: comment.line.number-sign.makefile
        - include: pop-on-line-end

  inside-function-call:
    - meta_content_scope: meta.function-call.arguments.makefile
    - match: \)
      scope: punctuation.definition.variable.end.makefile
      pop: true
    - match: \,
      scope: punctuation.separator.makefile
    - include: variable-substitutions
    - include: quoted-string

  function-invocations:
    - match: (\$\()(call)\s+([a-zA-Z0-9\-_]+)(,)
      captures:
        0: meta.function-call.makefile
        1: punctuation.definition.variable.begin.makefile
        2: constant.language.call.makefile
        3: support.function.makefile
        4: punctuation.separator.makefile
      push:
        - meta_content_scope: meta.function-call.arguments.makefile
        - include: inside-function-call
    - match: (\$\()(patsubst|filter)\s
      captures:
        0: meta.function-call.makefile
        1: punctuation.definition.variable.begin.makefile
        2: support.function.makefile
      push:
        - meta_content_scope: meta.function-call.arguments.makefile
        - include: highlight-percentage-sign
        - include: inside-function-call
    - match: (\$\()(wildcard)\s
      captures:
        0: meta.function-call.makefile
        1: punctuation.definition.variable.begin.makefile
        2: support.function.makefile
      push:
        - meta_content_scope: meta.function-call.arguments.makefile
        - include: inside-function-call
        - include: highlight-wildcard-sign
    - match: (?x) (\$\() (subst|strip|findstring|filter-out|sort|word|wordlist|words|firstword|lastword|dir|notdir|suffix|basename|addsuffix|addprefix|join|realpath|abspath|if|or|and|foreach|file|call|value|eval|origin|flavor|error|warning|info|guile) \s
      captures:
        0: meta.function-call.makefile
        1: punctuation.definition.variable.begin.makefile
        2: support.function.makefile
      push: inside-function-call
    - match: (\$\()(shell)\s
      captures:
        1: punctuation.definition.variable.begin.makefile
        2: support.function.builtin.makefile
      push: scope:source.shell
      with_prototype:
        - match: \)
          scope: punctuation.definition.variable.end.makefile
          pop: true
        - include: variable-substitutions

  variable-definitions:
    - match: \s*(override)\b
      captures:
        1: keyword.control.makefile
      set:
        - match: \bdefine\b
          scope: keyword.control.makefile
          push: inside-define-directive-context
        - include: variable-definitions
        - include: continuation-or-pop-on-line-end
    - match: \s*(define)\b
      captures:
        1: keyword.control.makefile
      push: inside-define-directive-context
    - match: ^\s*(export)\b
      captures:
        1: keyword.control.makefile
      push:
        - meta_content_scope: variable.other.makefile 
        - include: continuation-or-pop-on-line-end
        - include: variable-substitutions
        - match: (\?|\+|::?)?=
          scope: keyword.operator.assignment.makefile
          set: value-to-be-defined
    - match: (?={{var_lookahead}}|{{first_assign_then_colon}})
      push:
        - meta_content_scope: variable.other.makefile
        - match: (?=\s*!=)
          set:
            - match: '!='
              scope: keyword.operator.assignment.makefile
              set: scope:source.shell
              with_prototype:
                - include: variable-substitutions
                - include: pop-on-line-end
        - match: (?=\s*(!|\?|\+|::?)?=)
          set:
            - match: (!|\?|\+|::?)?=
              scope: keyword.operator.assignment.makefile
              set: value-to-be-defined
            - include: variable-substitutions
            - include: continuation-or-pop-on-line-end
        - include: variable-substitutions

  value-to-be-defined:
    - meta_content_scope: string.unquoted.makefile
    - include: escape-literals
    - match: (?=#)
      set:
        - match: \#
          scope: punctuation.definition.comment.makefile
          set:
            - meta_scope: comment.line.number-sign.makefile
            - include: pop-on-line-end
    - include: variable-substitutions
    - include: continuation-or-pop-on-line-end

  inside-define-directive-context:
    - meta_content_scope: variable.other.makefile
    - match: \s*(?=(!|\?|\+|::?)?=)
      set:
        - match: (!|\?|\+|::?)?=
          scope: keyword.operator.assignment.makefile
          set:
            - meta_content_scope: string.unquoted.makefile
            - match: ^\s*(endef)
              captures:
                1: keyword.control.makefile
              pop: true
    - match: $
      set:
        - meta_content_scope: string.unquoted.makefile
        - match: ^\s*(endef)
          captures:
            1: keyword.control.makefile
          pop: true  
    - include: variable-substitutions

  variable-sub-common:
    - match: ':'
      scope: punctuation.definition.substitution.makefile
    - match: =
      scope: punctuation.definition.assignment.makefile
    - include: highlight-percentage-sign
    - include: variable-substitutions

  variable-substitutions:
    - include: function-invocations
    - match: \$\$?\(
      scope: punctuation.definition.variable.begin.makefile
      push:
        - meta_scope: variable.other.makefile
        - match: \)
          scope: punctuation.definition.variable.end.makefile
          pop: true
        - include: variable-sub-common
    - match: \$\$?{
      scope: punctuation.definition.variable.end.makefile
      push:
        - meta_scope: variable.other.makefile
        - match: \}
          scope: punctuation.definition.variable.end.makefile
          pop: true
        - include: variable-sub-common
    - match: \$\$?[@%<?^+|*]
      scope: variable.language.automatic.makefile
    - match: \$\$
      scope: constant.character.escape.makefile
    - match: (\$)[[:alpha:]]
      captures:
        0: variable.other.makefile
        1: punctuation.definition.variable.makefile
