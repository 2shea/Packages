%YAML 1.2
# [Sublime]: https://www.sublimetext.com/docs/3/syntax.html
# [Bash]:    https://www.gnu.org/software/bash/manual/bash.html
--- #---------------------------------------------------------------------------

name: Bourne Again Shell (bash)

# The suffix is bash, but we still use .shell as a suffix anyway. This is to
# promote reusability of foreign scopes.
scope: source.shell.bash

file_extensions:
  - sh
  - bash
  - zsh
  - fish
  - .bash_aliases
  - .bash_functions
  - .bash_login
  - .bash_logout
  - .bash_profile
  - .bash_variables
  - .bashrc
  - .profile
  - .textmate_init

first_line_match: '^#!.*\b(bash|zsh|sh|tcsh)\b|^#\s*-\*-[^*]*mode:\s*shell-script[^*]*-\*-'

#-------------------------------------------------------------------------------
variables:
  identifier: '[[:alpha:]_][[:alnum:]_]*'
  metachar: '[/$`=|&;()<>\s]'
  identifier_non_posix: '[^{{metachar}}\d][^{{metachar}}]*' 
  nbc: '[^{}=\s]*' # non bracket characters (and also non-whitespace)
  is_start_of_arguments: '[`=|&;()<>\s]'
  is_variable: (?=\s*{{nbc}}(?:\{{{nbc}}\})?{{nbc}}=)
  is_function: \b(function)\s+|(?=\s*{{identifier_non_posix}}\s*\(\s*\))
  is_command: \s*(?=\S)
  is_end_of_option: '[^\w$-]|$'
  is_end_of_interpolation: \)
  is_path_component: (?=[^\s/]*/)
  extension: \.sh
  call_token: \./

  varassign: '[+\-?]?='
  start_of_option: (?:\s+|^)--?(?=[\w$])
  cmd_boundary: (?=\s|;|$|>|<)
  keyword_boundary_end: (?=[^\w_-])

  reset_semicolon: \s*(;)(?![;&])
  reset_or: \s*(\|\|)
  reset_and: \s*(&&)
  reset_pipe: \s*(\|)
#-------------------------------------------------------------------------------
contexts:

  comment:
    - match: (?:^\s*|\s+)(\#)
      captures:
        1: comment.line.number-sign.shell punctuation.definition.comment.begin.shell
      push:
        - meta_content_scope: comment.line.number-sign.shell
        - match: $
          pop: true

  line-continuation-or-pop-at-end:
    - include: pop-at-end
    - include: line-continuation

  pop-at-end:
    - match: $
      pop: true

  any-escape:
    - match: \\.
      scope: constant.character.escape.shell

  line-continuation:
    - match: \\\n
      scope: punctuation.separator.continuation.line.shell
      push:
        - match: ^
          pop: true
    - match: \\(\s+)\n
      captures:
        1: invalid.illegal.extraneous-spaces-after-line-continuation.shell
  
  prototype:
    - include: comment
    - include: line-continuation
    - include: any-escape

  main:
    - include: funcdef
    - include: vardef
    - match: '{{is_command}}'
      push: cmd

  # NOTE: Contexts with a "-bt" suffix are the "backtick" contexts. They mirror
  # the ordinary contexts, except that when a backtick is encountered while in
  # a "-bt" context, we pop.
  # Normally, we are in a non-bt context. When we encounter a backtick character
  # (the ` character), we enter the main-bt context. Popping when encountering
  # another ` character then ensures that we don't enter yet another backtick
  # context.
  # The "expansion" context is the **only** place where this main-bt context is
  # used. If you, the reader, knows of a more elegant way to handle backticks,
  # don't hesitate to change it.
  main-bt:
    - include: funcdef-bt
    - include: vardef-bt
    - match: '{{is_command}}'
      push: cmd-bt

  control:
    - match: \b(if){{keyword_boundary_end}}(?:\s*(!))?
      captures:
        1: keyword.control.if.begin.shell
        2: keyword.operator.logical.shell
    - match: \bthen\b
      scope: keyword.control.if.then.shell
      pop: true
    - match: \b(elif){{keyword_boundary_end}}(?:\s*(!))?
      captures:
        1: keyword.control.if.elif.shell
        2: keyword.operator.logical.shell
    - match: \bfi{{keyword_boundary_end}}
      scope: keyword.control.if.end.shell
      set: [cmd-post, cmd-args]
    - match: \belse{{keyword_boundary_end}}
      scope: keyword.control.if.else.shell
      pop: true
    - match: \bfor{{keyword_boundary_end}}
      scope: keyword.control.for.shell
      set: [cmd-post, for-args]
    - match: \bdo{{keyword_boundary_end}}
      scope: keyword.control.do.shell
      pop: true
    - match: \bdone{{keyword_boundary_end}}
      scope: keyword.control.done.shell
      set: [cmd-post, cmd-args]
    - match: \bwhile{{keyword_boundary_end}}
      scope: keyword.control.while.shell
    - match: \buntil{{keyword_boundary_end}}
      scope:  keyword.control.until.shell
    - match: \bcase{{keyword_boundary_end}}
      scope: keyword.control.case.begin.shell
      set: [case-body, case-item, case-item-first-character, case-preamble]
    - match: \bcontinue{{keyword_boundary_end}}
      scope: keyword.control.continue.shell
    - match: \bbreak{{keyword_boundary_end}}
      scope: keyword.control.break.shell
      set: [cmd-post, cmd-args]

  case-preamble:
    - match: \bin(?=[^\w_-])
      scope: keyword.control.case.in.shell
      pop: true
    - include: expansion-and-string

  case-item-highlights:
    - include: expansion-and-string
    - match: \|
      scope: keyword.operator.logical.shell
    - match: \(
      scope: punctuation.section.parens.begin.shell
      push: case-item-inside

  case-item-inside:
    - match: \)
      scope: punctuation.section.parens.end.shell
      pop: true
    - include: case-item-highlights

  case-item:
    - match: \)
      scope: keyword.control.case.item.shell
      pop: true
    - include: case-item-highlights

  case-item-first-character:
    - match: (?=\()
      set:
        - match: \(
          scope: keyword.control.case.item.shell
          pop: true
    - match: (?=\S)
      pop: true

  case-body:
    - match: \s*(;;&?|;&)
      captures:
        1: punctuation.terminator.case.shell
      set:
        # An opening parenthesis is optional
        - match: (?=\()
          set:
            - match: \(
              scope: keyword.control.case.item.shell
              set: case-body-item
        - match: (?=\S)
          set: case-body-item
    - match: \s*\b(esac)\b
      captures:
        1: keyword.control.case.end.shell
      pop: true
    - include: main

  case-body-item:
    - match: \besac\b
      scope: keyword.control.case.end.shell
      pop: true
    - match: \)
      scope: keyword.control.case.item.shell
      set: case-body
    - include: case-item-highlights

  # I don't think anybody will write a for-loop inside backticks. Hence no
  # for-args-bt context.
  for-args:
    - match: ""
      set:
        - meta_scope: meta.group.for.shell
        - include: cmd-args-boilerplate
        - include: compound
        - match: \bin\b
          scope: keyword.control.in.shell

  expansion-and-string:
    - include: string
    - include: expansion
 
  funcdef:
    - match: '{{is_function}}'
      captures:
        1: storage.type.function.shell
      push: [funcdef-body, funcdef-parens, funcdef-name]

  funcdef-bt:
    - match: '{{is_function}}'
      captures:
        1: storage.type.function.shell
      push: [funcdef-body-bt, funcdef-parens, funcdef-name]

  funcdef-name:
    - match: \s*
      set:
        - meta_content_scope: entity.name.function.shell
        - match: (?=\s*[({])
          pop: true

  funcdef-parens:
    - match: \(
      scope: punctuation.section.parens.begin.shell
      push:
        - match: \)
          scope: punctuation.section.parens.end.shell
          pop: true
    - match: \{
      scope: punctuation.section.braces.begin.shell
      pop: true

  funcdef-body:
    - meta_scope: meta.function.shell
    - match: \}
      scope: punctuation.section.braces.end.shell
      pop: true
    - include: main

  funcdef-body-bt:
    - meta_scope: meta.function.shell
    - match: \}
      scope: punctuation.section.braces.end.shell
      pop: true
    - include: main-bt

  vardef:
    - match: \s*\b(alias){{keyword_boundary_end}}
      captures:
        1: support.function.alias.shell
      push:
      - vardef-export-maybe-more
      - vardef-value
      - vardef-assign
      - vardef-name
      - vardef-alias-options
    - match: \s*\b(declare|local){{keyword_boundary_end}}
      captures:
        1: storage.modifier.shell
      push:
      - vardef-export-maybe-more
      - vardef-value
      - vardef-assign
      - vardef-name
      - vardef-declare-options
    - match: \s*\b(export|readonly|typeset){{keyword_boundary_end}}
      captures:
        1: storage.modifier.shell
      push:
      - vardef-export-maybe-more
      - vardef-value
      - vardef-assign
      - vardef-name
    - match: '{{is_variable}}'
      push:
      - vardef-value
      - vardef-assign
      - vardef-name

  vardef-bt:
    - match: \s*\b(alias){{keyword_boundary_end}}
      captures:
        1: support.function.alias.shell
      push:
      - vardef-export-maybe-more
      - vardef-value
      - vardef-assign
      - vardef-name
      - vardef-alias-options
    - match: \s*\b(declare|local){{keyword_boundary_end}}
      captures:
        1: storage.modifier.shell
      push:
      - vardef-export-maybe-more
      - vardef-value
      - vardef-assign
      - vardef-name
      - vardef-declare-options
    - match: \s*\b(export|readonly|typeset){{keyword_boundary_end}}
      captures:
        1: storage.modifier.shell
      push:
      - vardef-export-maybe-more
      - vardef-value
      - vardef-assign
      - vardef-name
    - match: '{{is_variable}}'
      push:
      - vardef-value
      - vardef-assign
      - vardef-name

  vardef-export-maybe-more:
    - match: (?=\s*#)
      pop: true
    - include: cmd-args-boilerplate
    - match: (?=\S)
      set:
      - vardef-export-maybe-more
      - vardef-value
      - vardef-assign
      - vardef-name

  vardef-alias-options:
    - match: \s*((-)p)
      captures:
        2: punctuation.definition.parameter.shell
        1: variable.parameter.shell
    - match: \s*
      pop: true

  vardef-declare-options:
    - match: \s*((-)(?:[aAfFgilnrtux]+|p))
      captures:
        2: punctuation.definition.parameter.shell
        1: variable.parameter.shell
    - match: \s*
      pop: true

  vardef-name:
    - match: \s*
      set:
        - meta_include_prototype: false
        - meta_content_scope: variable.other.readwrite.assignment.shell
        - include: line-continuation-or-pop-at-end
        - include: any-escape
        - match: (?={{varassign}}|\s)|$
          pop: true
        - include: array
        - match: \s*$
          pop: true
        - include: string

  vardef-assign:
    - meta_include_prototype: false
    - include: line-continuation-or-pop-at-end
    - include: any-escape
    - match: '{{varassign}}'
      scope: keyword.operator.assignment.shell
      pop: true
    - match: ""
      pop: true

  vardef-value:
    - match: \(
      scope: punctuation.section.parens.begin.shell
      set:
        - match: \)
          scope: punctuation.section.parens.end.shell
          pop: true
        - match: \[
          scope: punctuation.section.brackets.begin.shell
          push:
            - match: \]
              scope: punctuation.section.brackets.end.shell
              set:
                - match: =
                  scope: keyword.operator.assignment.shell
                  pop: true
                - match: ""
                  pop: true
            - include: expansion-and-string
        - include: expansion-and-string
    - match: ""
      set:
        - meta_include_prototype: false
        - meta_scope: string.unquoted.shell
        - include: expansion-and-string
        - include: line-continuation-or-pop-at-end
        - include: any-escape
        - match: (?=[\s;])
          pop: true

  redirection:
    - include: redirection-here-string
    - include: redirection-here-document
    - include: redirection-process
    - include: redirection-input
    - include: redirection-output
    - include: redirection-inout

  redirection-process:
    - match: (\d*)([<>])(\()
      captures:
        1: constant.numeric.file-descriptor.shell
        2: keyword.operator.assignment.redirection.process.shell
        3: punctuation.section.parens.begin.shell
      push:
        - match: \)
          scope: punctuation.section.parens.end.shell
          pop: true
        - include: main

  redirection-output:
    - match: (\d*)(>>!?|>&?|&>|&?>(\||>))(\d*)\s*
      captures:
        1: constant.numeric.file-descriptor.shell
        2: keyword.operator.assignment.redirection.shell
        4: constant.numeric.file-descriptor.shell

  redirection-input:
    - match: (\d*)(<&?)((-)|(\d+))?\s*
      captures:
        1: constant.numeric.file-descriptor.shell
        2: keyword.operator.assignment.redirection.shell
        4: punctuation.terminator.shell
        5: constant.numeric.file-descriptor.shell

  redirection-inout:
    - match: (\d*)(<>)
      captures:
        1: constant.numeric.file-descriptor.shell
        2: keyword.operator.assignment.redirection.shell

  redirection-here-string:
    - match: (\d*)(<<<)\s
      captures:
        1: constant.numeric.file-descriptor.shell
        2: keyword.operator.herestring.shell

  redirection-here-document:
    # These are the variants that allow tabs before the end token
    - match: (\d*)(<<-)\s*(')({{identifier}})(')
      captures:
        1: constant.numeric.file-descriptor.shell
        2: keyword.operator.assignment.redirection.shell
        3: punctuation.definition.string.begin.shell
        4: keyword.control.heredoc-token.shell
        5: punctuation.definition.string.end.shell
      push: [heredocs-body-allow-tabs-no-expansion, heredocs-preamble]
    - match: (\d*)(<<-)\s*(")({{identifier}})(")
      captures:
        1: constant.numeric.file-descriptor.shell
        2: keyword.operator.assignment.redirection.shell
        3: punctuation.definition.string.begin.shell
        4: keyword.control.heredoc-token.shell
        5: punctuation.definition.string.end.shell
      push: [heredocs-body-allow-tabs-no-expansion, heredocs-preamble]
    - match: (\d*)(<<-)\s*(\\)({{identifier}})
      captures:
        1: constant.numeric.file-descriptor.shell
        2: keyword.operator.assignment.redirection.shell
        3: punctuation.definition.string.shell
        4: keyword.control.heredoc-token.shell
      push: [heredocs-body-allow-tabs-no-expansion, heredocs-preamble]
    - match: (\d*)(<<-)\s*({{identifier}})
      captures:
        1: constant.numeric.file-descriptor.shell
        2: keyword.operator.assignment.redirection.shell
        3: keyword.control.heredoc-token.shell
      push: [heredocs-body-allow-tabs, heredocs-preamble]
    # These are the variants that DON'T allow tabs before the end token
    - match: (\d*)(<<)\s*(')({{identifier}})(')
      captures:
        1: constant.numeric.file-descriptor.shell
        2: keyword.operator.assignment.redirection.shell
        3: punctuation.definition.string.begin.shell
        4: keyword.control.heredoc-token.shell
        5: punctuation.definition.string.end.shell
      push: [heredocs-body-no-expansion, heredocs-preamble]
    - match: (\d*)(<<)\s*(")({{identifier}})(")
      captures:
        1: constant.numeric.file-descriptor.shell
        2: keyword.operator.assignment.redirection.shell
        3: punctuation.definition.string.begin.shell
        4: keyword.control.heredoc-token.shell
        5: punctuation.definition.string.end.shell
      push: [heredocs-body-no-expansion, heredocs-preamble]
    - match: (\d*)(<<)\s*(\\)({{identifier}})
      captures:
        1: constant.numeric.file-descriptor.shell
        2: keyword.operator.assignment.redirection.shell
        3: punctuation.definition.string.shell
        4: keyword.control.heredoc-token.shell
      push: [heredocs-body-no-expansion, heredocs-preamble]
    - match: (\d*)(<<)\s*({{identifier}})
      captures:
        1: constant.numeric.file-descriptor.shell
        2: keyword.operator.assignment.redirection.shell
        3: keyword.control.heredoc-token.shell
      push: [heredocs-body, heredocs-preamble]

  heredocs-body:
    - meta_include_prototype: false
    - meta_scope: string.unquoted.heredoc.shell
    - include: heredocs-body-common-with-expansion
    - match: ^\3(\s+)\n # the third capture from redirection-here-document
      captures:
        1: invalid.illegal.no-spaces-allowed-after-heredoc-token.shell
      # rather not pop, but sublime throws an error otherwise.
      pop: true
    - match: ^\3$ # the third capture from redirection-here-document
      scope: keyword.control.heredoc-token.shell
      pop: true

  heredocs-body-allow-tabs:
    - meta_include_prototype: false
    - meta_scope: string.unquoted.heredoc.shell
    - include: heredocs-body-common-with-expansion
    - match: ^\s*\3(\s+)\n # the third capture from redirection-here-document
      captures:
        1: invalid.illegal.no-spaces-allowed-after-heredoc-token.shell
      # rather not pop, but sublime throws an error otherwise.
      pop: true
    - match: ^\s*(\3)$ # the third capture from redirection-here-document
      captures:
        1: keyword.control.heredoc-token.shell
      pop: true

  heredocs-body-common-with-expansion:
    - match: \\[`$"\\]
      scope: constant.character.escape.backtick.shell
    - include: expansion

  heredocs-body-no-expansion:
    - meta_include_prototype: false
    - meta_scope: string.unquoted.heredoc.shell
    - match: ^\4(\s+)\n # the fourth capture from redirection-here-document
      captures:
        1: invalid.illegal.no-spaces-allowed-after-heredoc-token.shell
      # rather not pop, but sublime throws an error otherwise.
      pop: true
    - match: ^\4$ # the fourth capture from redirection-here-document
      scope: keyword.control.heredoc-token.shell
      pop: true

  heredocs-body-allow-tabs-no-expansion:
    - meta_include_prototype: false
    - meta_scope: string.unquoted.heredoc.shell
    - match: ^\s*\4(\s+)\n # the fourth capture from redirection-here-document
      captures:
        1: invalid.illegal.no-spaces-allowed-after-heredoc-token.shell
      # rather not pop, but sublime throws an error otherwise.
      pop: true
    - match: ^\s*(\4)$ # the fourth capture from redirection-here-document
      captures:
        1: keyword.control.heredoc-token.shell
      pop: true

  heredocs-preamble:
    - match: ""
      set:
        # This enables us to keep parsing on the line where the start token of
        # the heredoc is. Once the first line has ended, we enter the body of
        # the heredoc, where everything is just an unquoted string.
        # One clear_scope for the string.unquoted.
        # The problem with this is that when we also end a function definition
        # on the same line (with the "}" token), we cannot do that.
        - clear_scopes: 1
        - match: $
          pop: true
        - match: \s*(?=\S)
          push: [main-with-pop-at-end, cmd-post, cmd-args]

  main-with-pop-at-end:
    - include: line-continuation-or-pop-at-end
    - include: main

  cmd-name-common:
    - match: (?=}|\s+#|\s*(?:[|;]|&&))
      pop: true
    - include: string
    - include: expansion-parameter
    - include: expansion-arithmetic
    - include: expansion-command
    - include: expansion-tilde
    - include: line-continuation-or-pop-at-end

  cmd-args-common:
    - match: (?=}|\s+#)
      pop: true
    - include: redirection
    - match: (?=\s*([|;]|&&))
      pop: true
    - include: expansion-and-string
    - include: line-continuation-or-pop-at-end
    - match: (?:\s+|^)--(?=\s|$)
      scope: keyword.operator.end-of-options.shell
      set:
        - meta_content_scope: meta.function-call.arguments.shell
        - include: redirection
        - match: (?=[)};&|])
          pop: true
        - include: expansion-and-string
        - include: line-continuation-or-pop-at-end

  cmd-post: # looks like [main, cmd-post] at this point
    - match: ""
      set:
        - meta_content_scope: meta.post-cmd.shell
        - match: '{{reset_semicolon}}'
          captures:
            1: keyword.operator.logical.continue.shell
          pop: true
        - match: '{{reset_or}}'
          captures:
            1: keyword.operator.logical.or.shell
          pop: true
        - match: '{{reset_pipe}}'
          captures:
            1: keyword.operator.logical.pipe.shell
          pop: true
        - match: '{{reset_and}}'
          captures:
            1: keyword.operator.logical.and.shell
          pop: true
        - match: ""
          pop: true

  cmd-post-bt: # looks like [main, cmd-post] at this point
    - match: ""
      set:
        - meta_content_scope: meta.post-cmd.shell
        - match: '{{reset_semicolon}}'
          captures:
            1: keyword.operator.logical.continue.shell
          set: cmd-bt
        - match: '{{reset_or}}'
          captures:
            1: keyword.operator.logical.or.shell
          set: cmd-bt
        - match: '{{reset_pipe}}'
          captures:
            1: keyword.operator.logical.pipe.shell
          set: cmd-bt
        - match: '{{reset_and}}'
          captures:
            1: keyword.operator.logical.and.shell
          set: cmd-bt
        - match: ""
          pop: true

  cmd-args-boilerplate:
    - match: (?={{is_end_of_interpolation}})
      pop: true
    - include: cmd-args-common

  cmd-args-boilerplate-bt:
    - match: (?={{is_end_of_interpolation}}|`) # <-------------- extra backtick
      pop: true
    - include: cmd-args-common

  cmd-args:
    - match: ""
      set:
        - meta_scope: meta.function-call.arguments.shell
        - include: cmd-args-boilerplate
        - match: '{{start_of_option}}'
          scope: punctuation.definition.parameter.shell
          push:
            - meta_scope: variable.parameter.shell
            - match: (?={{is_end_of_option}})
              pop: true
            - include: expansion-and-string

  cmd-args-bt:
    - match: ""
      set:
        - meta_scope: meta.function-call.arguments.shell
        - include: cmd-args-boilerplate-bt
        - match: '{{start_of_option}}'
          scope: punctuation.definition.parameter.shell
          push:
            - meta_scope: variable.parameter.shell
            - match: (?={{is_end_of_option}}|`) # <------------- extra backtick
              pop: true
            - include: expansion-and-string

  cmd:
    - include: cmd-common
    - include: scope:commands.builtin.shell.bash#main
    - match: \blet\b
      scope: support.function.let.bash
      push:
        - match: $
          pop: true
        - include: expression
    - match: (\[\[)(?=\s)
      captures:
        1: support.function.test.begin.shell
      set: [cmd-post, cmd-test-double-brace-args]
    - match: (\[)(?=\s)
      captures:
        1: support.function.test.begin.shell
      set: [cmd-post, cmd-test-brace-args]
    - match: (\{)(?=\s)
      captures:
        1: punctuation.definition.compound.braces.begin.shell
      push:
        - match: \}
          scope: punctuation.definition.compound.braces.end.shell
          set: [cmd-post, cmd-args]
        - include: main
    - match: (?=\S)
      set: [cmd-post, cmd-args, cmd-name]

  cmd-bt:
    - include: cmd-common
    - include: scope:commands.builtin.shell.bash#main-bt
    - match: \blet\b
      scope: support.function.let.bash
      push:
        - match: $|(?=\`)
          pop: true
        - include: expression
    - match: (\[\[)(?=\s)
      captures:
        1: meta.function-call.shell support.function.test.begin.shell
      set: [cmd-post, cmd-test-double-brace-args-bt]
    - match: (\[)(?=\s)
      captures:
        1: meta.function-call.shell support.function.test.begin.shell
      set: [cmd-post-bt, cmd-test-brace-args-bt]
    - match: (\{)(?=\s)
      captures:
        1: punctuation.definition.compound.braces.begin.shell
      push:
        - match: \}
          scope: punctuation.definition.compound.braces.end.shell
          set: [cmd-post-bt, cmd-args-bt]
        - include: main-bt
    - match: (?=\S)
      set: [cmd-post-bt, cmd-args-bt, cmd-name-bt]

  cmd-test-brace-args:
    - match: ""
      set:
        - meta_scope: meta.function-call.arguments.shell
        - include: cmd-args-boilerplate
        - match: \s+(\])
          captures:
            1: support.function.test.end.shell
          pop: true
        - include: expression-test

  cmd-test-brace-args-bt:
    - match: ""
      set:
        - meta_scope: meta.function-call.arguments.shell
        - include: cmd-args-boilerplate-bt
        - match: \s+(\])
          captures:
            1: support.function.test.end.shell
          pop: true
        - include: expression-test

  cmd-test-double-brace-args:
    - match: ""
      set:
        - meta_scope: meta.function-call.arguments.shell
        - match: \s+(\]\])
          captures:
            1: support.function.test.end.shell
          pop: true
        - include: expression-test
        # - include: cmd-args-boilerplate

  cmd-test-double-brace-args-bt:
    - match: ""
      set:
        - meta_scope: meta.function-call.arguments.shell
        - match: \s+(\]\])
          captures:
            1: support.function.test.end.shell
          pop: true
        - include: expression-test
        # - include: cmd-args-boilerplate-bt

  cmd-name:
    - match: ""
      set:
        - meta_scope: meta.function-call.shell variable.function.shell
        - match: (?={{is_start_of_arguments}}|{{is_end_of_interpolation}})
          pop: true
        - include: cmd-name-common

  cmd-name-bt:
    - match: ""
      set:
        - meta_scope: meta.function-call.shell variable.function.shell
        - match: (?={{is_start_of_arguments}}|{{is_end_of_interpolation}}|`) # <---------- extra backtick
          pop: true
        - include: cmd-name-common

  cmd-common:
    - include: control
    - include: compound
    - match: (?=\)|})
      pop: true
    - include: line-continuation-or-pop-at-end

  compound:
    - match: \(\((?=.+\)\))
      scope: punctuation.definition.expression.begin.shell
      push:
        - match: \)\)
          scope: punctuation.definition.expression.end.shell
          pop: true
        - include: expression
    - match: \(
      scope: punctuation.definition.compound.begin.shell
      push:
        - match: \)
          scope: punctuation.definition.compound.end.shell
          set: [cmd-post, cmd-args]
        - include: main

  expansion-tilde:
    - match: '~'
      scope: meta.group.expansion.tilde variable.language.tilde.shell

  expansion-brace:
    - match: \{
      scope: punctuation.section.expansion.brace.begin.shell
      push:
        - meta_scope: meta.group.expansion.brace.shell
        - match: \}
          scope: punctuation.section.expansion.brace.end.shell
          pop: true
        - match: \,
          scope: punctuation.separator.shell
        - include: expansion-and-string

  expansion-parameter:
    - match: (\$)(\{)
      captures:
        0: meta.group.expansion.parameter.shell
        1: punctuation.definition.variable.shell
        2: punctuation.section.expansion.parameter.begin.shell
      push:
        - meta_content_scope: meta.group.expansion.parameter.shell
        - meta_include_prototype: false
        - match: \!
          scope: keyword.operator.indirection.shell
          set: expansion-parameter-post-first-character
        - match: \#
          scope: keyword.operator.arithmetic.shell
          set: expansion-parameter-post-first-character
        - match: ""
          set: expansion-parameter-post-first-character
    - match: (\$)(\d)
      captures:
        0: meta.group.expansion.parameter.shell 
        1: punctuation.definition.variable.shell
        2: constant.numeric.integer.decimal.shell
    - match: (\$)([#@!~*?_-])(?!\w)
      captures:
        0: meta.group.expansion.parameter.shell 
        1: punctuation.definition.variable.shell
        2: variable.language.shell
    - match: (\$)({{identifier}})
      captures:
        0: meta.group.expansion.parameter.shell 
        1: punctuation.definition.variable.shell
        2: variable.other.readwrite.shell

  expansion-pattern:
    - match: ([?*+@!])(\()
      captures:
        1: keyword.operator.regexp.quantifier.shell
        2: punctuation.section.parens.begin.shell
      push:
        - match: \)
          scope: punctuation.section.parens.end.shell
          pop: true
        - match: \|
          scope: keyword.operator.logical.or.shell
        - include: expansion-and-string
    - match: '[*?]'
      scope: keyword.operator.regexp.quantifier.shell
    - match: \[
      scope: keyword.control.regexp.set.begin.shell
      push:
        - match: \]
          set: expansion-pattern-post-first-char
        - match: '[!^]'
          scope: keyword.operator.logical.not.shell
          set: expansion-pattern-post-first-char
        - match: \-
          set: expansion-pattern-post-first-char
        - match: ""
          set: expansion-pattern-post-first-char

  expansion-pattern-post-first-char:
    - match: (?:-)?(\])
      captures:
        1: keyword.control.regexp.set.end.shell
      pop: true
    - match: \-
      scope: keyword.operator.word.shell
    - match: (\.)[[:word:]](\.)
      captures:
        1: punctuation.separator.collate.begin.shell
        2: punctuation.separator.collate.end.shell
    - match: (=)[[:word:]](=)
      captures:
        1: punctuation.separator.equivalence-class.begin.shell
        2: punctuation.separator.equivalence-class.end.shell
    - match: (:)[[:lower:]]+(:)
      captures:
        1: punctuation.separator.character-class.begin.shell
        2: punctuation.separator.character-class.end.shell
    - include: expansion-and-string

  expansion-arithmetic:
    - match: (\$)(\(\()(?=.+\)\))
      captures:
        1: punctuation.definition.variable.shell
        2: punctuation.section.parens.begin.shell
      push:
        - meta_scope: meta.group.expansion.arithmetic.shell
        - match: \)\)
          scope: punctuation.section.parens.end.shell
          pop: true
        - include: expression

  expansion-command:
    - match: (\$)(\()
      captures:
        1: punctuation.definition.variable.shell
        2: punctuation.section.parens.begin.shell
      push:
        - meta_scope: meta.group.expansion.command.parens.shell
        - match: \s*(\))
          captures:
            1: punctuation.section.parens.end.shell
          pop: true
        - match: ""
          push: cmd
    - match: \`
      scope: punctuation.section.group.begin.shell
      push:
        - meta_scope: meta.group.expansion.command.backticks.shell
        - match: \`
          scope: punctuation.section.group.end.shell
          pop: true
        - include: main-bt # all those *-bt contexts just for this!!!!

  expansion:
    - include: expansion-pattern
    - include: expansion-parameter
    - include: expansion-brace
    - include: expansion-arithmetic
    - include: expansion-command
    - include: expansion-tilde

  expansion-parameter-common:
    - meta_content_scope: meta.group.expansion.parameter.shell
    - match: \}
      scope:
        meta.group.expansion.parameter.shell
        punctuation.section.expansion.parameter.end.shell
      pop: true
    - include: string
    - include: expansion-parameter
    # no brace expansion
    - include: expansion-arithmetic
    - include: expansion-command
    - include: expansion-tilde
    # no pattern expansion

  array:
    - match: \[
      scope: punctuation.section.braces.begin.shell
      push:
        - match: \]
          scope: punctuation.section.braces.end.shell
          pop: true
        - match: '[*@]'
          scope: variable.language.array.shell
        - include: expression

  expansion-parameter-post-first-character:
    - meta_content_scope:
        meta.group.expansion.parameter.shell 
        variable.other.readwrite.shell
    - include: expansion-parameter-common
    - match: (?=[@*]?/)
      set:
        - meta_content_scope: meta.group.expansion.parameter.shell 
        - match: ([@*])?(/)
          captures:
            1: variable.language.shell
            2: keyword.operator.substitution.shell
          set:
            - meta_include_prototype: false
            - meta_content_scope: meta.group.expansion.parameter.shell 
            - match: '[/#%]'
              scope: variable.parameter.switch.shell
              set: expansion-parameter-pattern
            - match: ""
              set: expansion-parameter-pattern
    - match: (?=\:?[-+=?])
      set:
        - meta_content_scope: meta.group.expansion.parameter.shell 
        - match: \:?[-+=?]
          scope: keyword.operator.assignment.shell
          set: expansion-parameter-common
    - match: (?=@?:)
      set:
        - meta_content_scope: meta.group.expansion.parameter.shell 
        - match: '(@)?(:)'
          captures:
            1: variable.language.shell
            2: keyword.operator.substring.begin.shell
          set:
            - meta_content_scope: meta.group.expansion.parameter.shell 
            - match: (?=:)
              set:
                - meta_content_scope: meta.group.expansion.parameter.shell
                - match: ":"
                  scope: keyword.operator.substring.end.shell
                  set:
                    - meta_content_scope: meta.group.expansion.parameter.shell
                    - include: expression
                    - include: expansion-parameter-common
            - include: expression
            - include: expansion-parameter-common
    - match: \#(?=})
    - match: ([@*])?(\#\#?|%%?|\^\^?|,,?)
      captures:
        1: variable.language.shell
        2: keyword.operator.expansion.shell
      set:
        - meta_content_scope: meta.group.expansion.parameter.shell 
        - include: expansion-parameter-common
        - include: expansion-pattern
    - match: ([@*]?)(@)([QEPAa])(?=})
      captures:
        1: variable.language.shell
        2: keyword.operator.expansion.shell
        3: variable.parameter.switch.shell
    - include: array
    - match: '[*@](?=})'
      scope: variable.language.shell

  expansion-parameter-pattern:
    - meta_content_scope: meta.group.expansion.parameter.shell
    - match: /
      scope: keyword.operator.substitution.shell
      set: expansion-parameter-common
    - include: expansion-parameter-common
    - include: expansion-pattern

  expression:
    - include: expansion-and-string
    - match: '[!~]'
      scope: keyword.operator.logical.shell
    - match: \b\d+
      scope: constant.numeric.integer.shell
    - match: \+\+?|\-\-?|\*\*?|%
      scope: keyword.operator.arithmetic.shell
    - match: <[=<]?|>[=>]?|[=!]=|&&|\:|\|\|
      scope: keyword.operator.logical.shell
    - match: '[&|^]'
      scope: keyword.operator.bitwise.shell
    - match: '[*/%+\-&^|]?=|<<=|>>='
      scope: keyword.operator.assignment.shell
    - match: \,
      scope: punctuation.separator.shell
    - match: ;
      scope: punctuation.separator.shell

  expression-test:
    - include: expansion-and-string
    - match: ((-)[aobcdefghknoprstuvwxzGLNORS])(?=\s)
      captures:
        2: punctuation.definition.parameter.shell
        1: variable.parameter.shell
    - match: ((-)(?:ef|nt|ot|eq|ne|lt|le|gt|ge))(?=\s)
      captures:
        2: punctuation.definition.parameter.shell
        1: variable.parameter.shell
    - match: (=~)\s*
      captures:
        1: keyword.operator.logical.shell
      push:
        - meta_content_scope: meta.regexp.shell
        - match: (?=\s)
          pop: true
        - include: expansion-and-string
    - match: ==?|!=?|<|>|\|\||&&
      scope: keyword.operator.logical.shell

  string:
    - include: string-quoted-double
    - include: string-quoted-single
    - include: string-ansi-c

  # nothing is escaped in a singly-quoted string!
  string-quoted-single:
    - match: \'
      scope: punctuation.definition.string.begin.shell
      push:
        - meta_include_prototype: false
        - meta_scope: string.quoted.single.shell
          scope: constant.character.escape.shell.zsh
        - match: \'
          scope: punctuation.definition.string.end.shell
          pop: true

  string-quoted-double:
    - match: \"
      scope: punctuation.definition.string.begin.shell
      push:
        - meta_include_prototype: false
        - meta_scope: string.quoted.double.shell
        - match: \"
          scope: punctuation.definition.string.end.shell
          pop: true
        - include: string-quoted-double-escape-character
        - include: expansion-parameter
        - include: expansion-arithmetic
        - include: expansion-command

  string-quoted-double-escape-character:
    - match: \\[$`"\\]
      scope: constant.character.escape.shell
    - match: \\\n
      scope: constant.character.escape.shell
      push:
        - meta_include_prototype: false
        - match: (?=\S)
          pop: true

  # [Bash] 3.1.2.4
  string-ansi-c:
    - match: \$'
      scope: punctuation.definition.string.begin.shell
      push:
        - meta_include_prototype: false
        # see 3.1.2.4 on why we choose string.quoted.single here
        - meta_scope: string.quoted.single.shell
        - match: "'"
          scope: punctuation.definition.string.end.shell
          pop: true
        - include: string-quoted-double-escape-character
        - match: \\([abfnrtv'"?]|[0-8]{1,3}|x\h{1,8}|c[a-z])
          scope: constant.character.escape.shell
